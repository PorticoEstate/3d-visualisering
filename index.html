<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Visualisering av sammenhenger</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            font-size: 12px;
        }
        #info h3 {
            margin-top: 0;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="graph-container"></div>
    <div id="info">
        <h3>Ecosystem 3D Graf</h3>
        <p>Klikk og dra for 친 rotere</p>
        <p>Scroll for 친 zoome</p>
        <p>Klikk p친 en node for detaljer og relasjonshighlighting</p>
        <p>Klikk p친 bakgrunnen for 친 fjerne highlighting</p>
    </div>
    <div id="controls">
        <label for="datasetSelect" style="display: block; margin-bottom: 5px;">Velg datasett:</label>
        <select id="datasetSelect" onchange="loadSelectedDataset()" style="width: 200px; margin-bottom: 10px;">
            <option value="">Laster...</option>
        </select>
        <br>
        <button onclick="resetCamera()" style="margin-right: 5px;">Reset Kamera</button>
        <button onclick="clearHighlight()" style="margin-right: 5px;">Fjern Highlighting</button>
    </div>

    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>

    <script>
        // Last inn datasettet fra ekstern fil
        let data = null;
        let Graph = null;
        let availableDatasets = [];
        let highlightNodes = new Set();
        let highlightLinks = new Set();
        let hoverNode = null;
        let nodeDistances = new Map(); // For storing distance from selected node

        // Funksjon for 친 hente tilgjengelige datasett
        async function loadAvailableDatasets() {
            try {
                const response = await fetch('data/datasets.json');
                availableDatasets = await response.json();
                
                const select = document.getElementById('datasetSelect');
                select.innerHTML = '';
                
                availableDatasets.forEach((dataset, index) => {
                    const option = document.createElement('option');
                    option.value = dataset.file;
                    option.textContent = dataset.name;
                    if (index === 0) option.selected = true;
                    select.appendChild(option);
                });
                
                // Last inn f칮rste datasett
                if (availableDatasets.length > 0) {
                    await loadDatasetFile(availableDatasets[0].file);
                }
            } catch (error) {
                console.error('Kunne ikke laste datasett-liste:', error);
                // Fallback til default fil
                await loadDatasetFile('ecosystem.js');
                const select = document.getElementById('datasetSelect');
                select.innerHTML = '<option value="ecosystem.js">ecosystem.js</option>';
            }
        }

        // Funksjon for 친 laste et datasett fra fil
        async function loadDatasetFile(filename) {
            try {
                const path = filename.includes('/') ? filename : `data/${filename}`;
                const response = await fetch(path);
                data = await response.json();
                
                if (Graph) {
                    // Oppdater eksisterende graf
                    Graph.graphData(data);
                } else {
                    // Initialiser graf f칮rste gang
                    initializeGraph();
                }
                
                document.getElementById('info').innerHTML = `
                    <h3>Ecosystem 3D Graf</h3>
                    <p><strong>Datasett:</strong> ${filename}</p>
                    <p><strong>Noder:</strong> ${data.nodes.length}</p>
                    <p><strong>Lenker:</strong> ${data.links.length}</p>
                    <p>Klikk p친 en node for detaljer</p>
                `;
            } catch (error) {
                console.error('Feil ved lasting av data:', error);
                document.getElementById('info').innerHTML = `
                    <h3>Feil</h3>
                    <p>Kunne ikke laste ${filename}</p>
                    <p>${error.message}</p>
                `;
            }
        }

        // Funksjon som kalles n친r bruker velger et nytt datasett
        function loadSelectedDataset() {
            const select = document.getElementById('datasetSelect');
            const selectedFile = select.value;
            if (selectedFile) {
                loadDatasetFile(selectedFile);
            }
        }

        function initializeGraph() {
            if (!data) return;

            // Fargepalett for gruppene
            const groupColors = {
                1: '#FF6B6B',  // Akt칮rer (r칮d)
                2: '#4ECDC4',  // Funksjoner (turkis)
                3: '#45B7D1',  // Teknologi (bl친)
                4: '#96CEB4',  // 칒konomi (gr칮nn)
                5: '#FFEAA7',  // Integrasjon (gul)
                6: '#DFE6E9',  // Sikkerhet (gr친)
                7: '#55EFC4',  // B칝rekraft (mintgr칮nn)
                8: '#A29BFE'   // Design (lilla)
            };

            // Opprett 3D graf
            Graph = ForceGraph3D()
                (document.getElementById('graph-container'))
                .graphData(data)
                .nodeLabel('id')
                .nodeAutoColorBy('group')
                .nodeColor(node => groupColors[node.group] || '#cccccc')
                .nodeRelSize(8)
                .nodeOpacity(0.9)
                .nodeThreeObject(node => {
                    // Hent THREE fra global scope
                    const THREE = window.THREE;
                    
                    // Lag en gruppe for node med tekst
                    const group = new THREE.Group();
                    
                    // Bestem farge, st칮rrelse og opacity basert p친 distance
                    let nodeColor = groupColors[node.group] || '#cccccc';
                    let nodeOpacity = 0.9;
                    let nodeSize = 8;
                    
                    if (highlightNodes.size > 0) {
                        if (!highlightNodes.has(node)) {
                            nodeOpacity = 0.2;
                            nodeSize = 6;
                        } else {
                            const distance = nodeDistances.get(node) || nodeDistances.get(node.id) || 0;
                            
                            if (distance === 0) {
                                // Selected node - largest and brightest
                                nodeColor = '#ffffff';
                                nodeOpacity = 1.0;
                                nodeSize = 12;
                            } else if (distance === 1) {
                                // 1 hop - bright and larger
                                nodeOpacity = 1.0;
                                nodeSize = 10;
                            } else if (distance === 2) {
                                // 2 hops - normal size, good opacity
                                nodeOpacity = 0.9;
                                nodeSize = 8;
                            } else {
                                // 3+ hops - smaller and more transparent
                                nodeOpacity = 0.7;
                                nodeSize = 7;
                            }
                        }
                    }
                    
                    // Lag sf칝re for noden
                    const sphereGeometry = new THREE.SphereGeometry(nodeSize);
                    const sphereMaterial = new THREE.MeshLambertMaterial({
                        color: nodeColor,
                        transparent: true,
                        opacity: nodeOpacity
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    
                    // Add glow effect for selected node
                    if (highlightNodes.has(node) && (nodeDistances.get(node) || nodeDistances.get(node.id) || 0) === 0) {
                        const glowGeometry = new THREE.SphereGeometry(nodeSize * 1.5);
                        const glowMaterial = new THREE.MeshLambertMaterial({
                            color: '#ffffff',
                            transparent: true,
                            opacity: 0.3
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        group.add(glow);
                    }
                    
                    group.add(sphere);
                    
                    // Lag tekst for nodenavn
                    const sprite = new THREE.Sprite(
                        new THREE.SpriteMaterial({
                            map: createTextTexture(node.id),
                            transparent: true,
                            depthTest: false,
                            depthWrite: false
                        })
                    );
                    sprite.position.y = nodeSize + 7;
                    sprite.scale.set(30, 10, 1);
                    sprite.renderOrder = 999;
                    
                    // Juster tekst opacity basert p친 highlighting
                    sprite.material.opacity = highlightNodes.size === 0 || highlightNodes.has(node) ? 1.0 : 0.2;
                    
                    group.add(sprite);
                    
                    return group;
                })
                .linkColor(link => {
                    if (highlightLinks.size === 0) {
                        return 'rgba(255,255,255,0.6)';
                    }
                    if (highlightLinks.has(link)) {
                        // Get distance from source node to create gradient effect
                        const sourceDistance = nodeDistances.get(link.source) || nodeDistances.get(link.source.id) || 0;
                        const targetDistance = nodeDistances.get(link.target) || nodeDistances.get(link.target.id) || 0;
                        const maxDistance = Math.max(sourceDistance, targetDistance);
                        
                        // Create color gradient from red (close) to blue (far)
                        if (maxDistance === 0) return '#ff3333'; // Selected node links - bright red
                        if (maxDistance === 1) return '#ff6666'; // 1 hop - red
                        if (maxDistance === 2) return '#ff9999'; // 2 hops - light red
                        if (maxDistance === 3) return '#66ccff'; // 3 hops - light blue
                        return '#3399ff'; // 4+ hops - blue
                    }
                    return 'rgba(100,100,100,0.1)'; // Non-highlighted links very faded
                })
                .linkWidth(link => {
                    if (highlightLinks.size === 0) {
                        return 1;
                    }
                    if (highlightLinks.has(link)) {
                        // Make links thicker for closer connections
                        const sourceDistance = nodeDistances.get(link.source) || nodeDistances.get(link.source.id) || 0;
                        const targetDistance = nodeDistances.get(link.target) || nodeDistances.get(link.target.id) || 0;
                        const maxDistance = Math.max(sourceDistance, targetDistance);
                        
                        if (maxDistance === 0) return 4; // Selected node links - thickest
                        if (maxDistance === 1) return 3; // 1 hop
                        if (maxDistance === 2) return 2; // 2 hops
                        return 1; // 3+ hops - normal width
                    }
                    return 0.5; // Non-highlighted links thinner
                })
                .linkOpacity(link => {
                    if (highlightLinks.size === 0) {
                        return 0.6;
                    }
                    if (highlightLinks.has(link)) {
                        // Fade opacity with distance
                        const sourceDistance = nodeDistances.get(link.source) || nodeDistances.get(link.source.id) || 0;
                        const targetDistance = nodeDistances.get(link.target) || nodeDistances.get(link.target.id) || 0;
                        const maxDistance = Math.max(sourceDistance, targetDistance);
                        
                        if (maxDistance === 0) return 1.0; // Selected node links - full opacity
                        if (maxDistance === 1) return 0.9; // 1 hop
                        if (maxDistance === 2) return 0.7; // 2 hops
                        if (maxDistance === 3) return 0.5; // 3 hops
                        return 0.3; // 4+ hops
                    }
                    return 0.1; // Non-highlighted links very faded
                })
                .onNodeClick(node => {
                    // Oppdater highlighting
                    updateHighlight(node);
                    
                    // Oppdater info-panelet
                    const totalConnected = highlightNodes.size - 1; // Subtract the clicked node itself
                    const directConnections = getConnectedNodes(node).length - 1; // Direct connections only
                    
                    document.getElementById('info').innerHTML = `
                        <h3>${node.id}</h3>
                        <p><strong>Gruppe:</strong> ${node.group}</p>
                        <p><strong>Direkte tilkoblinger:</strong> ${directConnections}</p>
                        <p><strong>Total nettverk (4 hopp):</strong> ${totalConnected}</p>
                        <p>${node.description}</p>
                        <hr>
                        <p style="font-size: 11px;"><strong>Farger:</strong></p>
                        <p style="font-size: 10px;">游댮 R칮d: N칝rme forbindelser (1-2 hopp)</p>
                        <p style="font-size: 10px;">游댯 Bl친: Fjerne forbindelser (3-4 hopp)</p>
                        <p style="font-size: 11px;"><strong>Klikk p친 en annen node eller bakgrunnen</strong></p>
                    `;
                    
                    // Flytt kameraet for 친 fokusere p친 noden
                    const distance = 200;
                    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
                    
                    Graph.cameraPosition(
                        { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // ny kameraposisjon
                        node, // se mot noden
                        1000  // animasjonstid i ms
                    );
                })
                .onBackgroundClick(() => {
                    // Fjern highlighting n친r man klikker p친 bakgrunnen
                    clearHighlight();
                    document.getElementById('info').innerHTML = `
                        <h3>Ecosystem 3D Graf</h3>
                        <p><strong>Datasett:</strong> ${document.getElementById('datasetSelect').value}</p>
                        <p><strong>Noder:</strong> ${data.nodes.length}</p>
                        <p><strong>Lenker:</strong> ${data.links.length}</p>
                        <p>Klikk p친 en node for detaljer og relasjonshighlighting</p>
                    `;
                })
                .nodeColor(node => {
                    if (highlightNodes.size === 0) {
                        return groupColors[node.group] || '#cccccc';
                    }
                    if (highlightNodes.has(node)) {
                        // Color nodes based on distance from selected node
                        const distance = nodeDistances.get(node) || nodeDistances.get(node.id) || 0;
                        const baseColor = groupColors[node.group] || '#cccccc';
                        
                        if (distance === 0) {
                            // Selected node - bright with white outline effect
                            return '#ffffff';
                        } else {
                            // Connected nodes - keep original color but make them bright
                            return baseColor;
                        }
                    }
                    return 'rgba(100,100,100,0.2)'; // Non-connected nodes very faded
                })
                .backgroundColor('#000000');
            
            // Funksjon for 친 lage tekst-tekstur
            function createTextTexture(text) {
                const THREE = window.THREE;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Ingen bakgrunn - transparent
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Tekst med skygge for bedre lesbarhet
                context.font = 'Bold 18px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Skygge/outline
                context.strokeStyle = 'black';
                context.lineWidth = 3;
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                
                // Hovedtekst
                context.fillStyle = 'white';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }
            
            // Helper functions for highlighting
            function getConnectedNodes(node) {
                const connectedNodes = new Set();
                connectedNodes.add(node);
                
                data.links.forEach(link => {
                    if (link.source === node || link.source.id === node.id) {
                        connectedNodes.add(link.target);
                    }
                    if (link.target === node || link.target.id === node.id) {
                        connectedNodes.add(link.source);
                    }
                });
                
                return Array.from(connectedNodes);
            }
            
            function updateHighlight(node) {
                // Clear previous highlights
                highlightNodes.clear();
                highlightLinks.clear();
                nodeDistances.clear();
                
                if (node) {
                    // Use BFS to find all connected nodes and their distances
                    const queue = [{node: node, distance: 0}];
                    const visited = new Set();
                    const maxDistance = 4; // Limit propagation to 4 hops
                    
                    visited.add(node.id || node);
                    nodeDistances.set(node, 0);
                    highlightNodes.add(node);
                    
                    while (queue.length > 0) {
                        const {node: currentNode, distance} = queue.shift();
                        
                        if (distance >= maxDistance) continue;
                        
                        // Find all connected nodes
                        data.links.forEach(link => {
                            let connectedNode = null;
                            let isConnected = false;
                            
                            if (link.source === currentNode || link.source.id === (currentNode.id || currentNode)) {
                                connectedNode = link.target;
                                isConnected = true;
                            } else if (link.target === currentNode || link.target.id === (currentNode.id || currentNode)) {
                                connectedNode = link.source;
                                isConnected = true;
                            }
                            
                            if (isConnected && connectedNode) {
                                const connectedNodeId = connectedNode.id || connectedNode;
                                
                                // Add the link to highlighting
                                highlightLinks.add(link);
                                
                                // If we haven't visited this node yet, add it
                                if (!visited.has(connectedNodeId)) {
                                    visited.add(connectedNodeId);
                                    nodeDistances.set(connectedNode, distance + 1);
                                    highlightNodes.add(connectedNode);
                                    
                                    // Add to queue for further exploration
                                    if (distance + 1 < maxDistance) {
                                        queue.push({node: connectedNode, distance: distance + 1});
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Update graph display
                Graph.nodeColor(Graph.nodeColor());
                Graph.linkColor(Graph.linkColor());
                Graph.linkWidth(Graph.linkWidth());
                Graph.linkOpacity(Graph.linkOpacity());
                Graph.nodeThreeObject(Graph.nodeThreeObject());
            }
            
            function clearHighlight() {
                highlightNodes.clear();
                highlightLinks.clear();
                nodeDistances.clear();
                
                // Update graph display
                Graph.nodeColor(Graph.nodeColor());
                Graph.linkColor(Graph.linkColor());
                Graph.linkWidth(Graph.linkWidth());
                Graph.linkOpacity(Graph.linkOpacity());
                Graph.nodeThreeObject(Graph.nodeThreeObject());
            }

            // Animer grafen litt ved start
            setTimeout(() => {
                Graph.cameraPosition(
                    { x: 200, y: 200, z: 600 },
                    { x: 0, y: 0, z: 0 },
                    3000
                );
            }, 1000);

            // Kamera kontroll funksjon (globalt tilgjengelig)
            window.resetCamera = function() {
                Graph.cameraPosition(
                    { x: 0, y: 0, z: 1000 },
                    { x: 0, y: 0, z: 0 },
                    1000
                );
            };
            
            // Make clearHighlight globally available
            window.clearHighlight = clearHighlight;
        }

        // Start lasting av datasett n친r siden er lastet
        loadAvailableDatasets();
    </script>
</body>
</html>
